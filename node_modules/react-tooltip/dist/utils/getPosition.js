'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (e, target, node, place, effect, offset) {
  var tipWidth = node.clientWidth;
  var tipHeight = node.clientHeight;

  var _getCurrentOffset = getCurrentOffset(e, target, effect);

  var mouseX = _getCurrentOffset.mouseX;
  var mouseY = _getCurrentOffset.mouseY;

  var defaultOffset = getDefaultPosition(effect, target.clientWidth, target.clientHeight, tipWidth, tipHeight);

  var _calculateOffset = calculateOffset(offset);

  var extraOffset_X = _calculateOffset.extraOffset_X;
  var extraOffset_Y = _calculateOffset.extraOffset_Y;


  var widnowWidth = window.innerWidth;
  var windowHeight = window.innerHeight;

  // Get the edge offset of the tooltip
  var getTipOffsetLeft = function getTipOffsetLeft(place) {
    var offset_X = defaultOffset[place].x;
    return mouseX + offset_X + extraOffset_X;
  };
  var getTipOffsetTop = function getTipOffsetTop(place) {
    var offset_Y = defaultOffset[place].y;
    return mouseY + offset_Y + extraOffset_Y;
  };

  // Judge if the tooltip has over the window(screen)
  var outsideLeft = function outsideLeft() {
    // if switch to right will out of screen, return false because switch placement doesn't make sense
    return getTipOffsetLeft('left') < 0 && getTipOffsetLeft('right') <= widnowWidth;
  };
  var outsideRight = function outsideRight() {
    return getTipOffsetLeft('right') > widnowWidth && getTipOffsetLeft('left') >= 0;
  };
  var outsideTop = function outsideTop() {
    return getTipOffsetTop('top') < 0 && getTipOffsetTop('bottom') + tipHeight <= windowHeight;
  };
  var outsideBottom = function outsideBottom() {
    return getTipOffsetTop('bottom') + tipHeight > windowHeight && getTipOffsetTop('top') >= 0;
  };

  // Return new state to change the placement to the reverse if possible
  if (place === 'left' && outsideLeft()) {
    return {
      isNewState: true,
      newState: { place: 'right' }
    };
  } else if (place === 'right' && outsideRight()) {
    return {
      isNewState: true,
      newState: { place: 'left' }
    };
  } else if (place === 'top' && outsideTop()) {
    return {
      isNewState: true,
      newState: { place: 'bottom' }
    };
  } else if (place === 'bottom' && outsideBottom()) {
    return {
      isNewState: true,
      newState: { place: 'top' }
    };
  }

  // Return tooltip offset position
  return {
    isNewState: false,
    position: {
      left: getTipOffsetLeft(place),
      top: getTipOffsetTop(place)
    }
  };
};

// Get current mouse offset
var getCurrentOffset = function getCurrentOffset(e, currentTarget, effect) {
  var boundingClientRect = currentTarget.getBoundingClientRect();
  var targetTop = boundingClientRect.top;
  var targetLeft = boundingClientRect.left;
  var targetWidth = currentTarget.clientWidth;
  var targetHeight = currentTarget.clientHeight;

  if (effect === 'float') {
    return {
      mouseX: e.clientX,
      mouseY: e.clientY
    };
  }
  return {
    mouseX: targetLeft + targetWidth / 2,
    mouseY: targetTop + targetHeight / 2
  };
};

// List all possibility of tooltip final offset
// This is useful in judging if it is necessary for tooltip to switch position when out of window
/**
 * Calculate the position of tooltip
 *
 * @params
 * - `e` {Event} the event of current mouse
 * - `target` {Element} the currentTarget of the event
 * - `node` {DOM} the react-tooltip object
 * - `place` {String} top / right / bottom / left
 * - `effect` {String} float / solid
 * - `offset` {Object} the offset to default position
 *
 * @return {Object
 * - `isNewState` {Bool} required
 * - `newState` {Object}
 * - `position` {OBject} {left: {Number}, top: {Number}}
 */
var getDefaultPosition = function getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight) {
  var top = void 0;
  var right = void 0;
  var bottom = void 0;
  var left = void 0;
  var disToMouse = 15;
  var triangleHeight = 5;

  if (effect === 'float') {
    top = { x: -(tipWidth / 2), y: -(tipHeight + disToMouse - triangleHeight) };
    bottom = { x: -(tipWidth / 2), y: disToMouse };
    left = { x: -(tipWidth + disToMouse - triangleHeight), y: -(tipHeight / 2) };
    right = { x: disToMouse, y: -(tipHeight / 2) };
  } else if (effect === 'solid') {
    top = { x: -(tipWidth / 2), y: -(targetHeight / 2 + tipHeight) };
    bottom = { x: -(tipWidth / 2), y: targetHeight / 2 };
    left = { x: -(tipWidth + targetWidth / 2), y: -(tipHeight / 2) };
    right = { x: targetWidth / 2, y: -(tipHeight / 2) };
  }

  return { top: top, bottom: bottom, left: left, right: right };
};

// Consider additional offset into position calculation
var calculateOffset = function calculateOffset(offset) {
  var extraOffset_X = 0;
  var extraOffset_Y = 0;

  if (Object.prototype.toString.apply(offset) === '[object String]') {
    offset = JSON.parse(offset.toString().replace(/\'/g, '\"'));
  }
  for (var key in offset) {
    if (key === 'top') {
      extraOffset_Y -= parseInt(offset[key], 10);
    } else if (key === 'bottom') {
      extraOffset_Y += parseInt(offset[key], 10);
    } else if (key === 'left') {
      extraOffset_X -= parseInt(offset[key], 10);
    } else if (key === 'right') {
      extraOffset_X += parseInt(offset[key], 10);
    }
  }

  return { extraOffset_X: extraOffset_X, extraOffset_Y: extraOffset_Y };
};